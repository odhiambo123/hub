<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-30T13:12:50-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Code snippets</title><link href="http://localhost:4000/javascript/2022/07/29/Code-Snipets.html" rel="alternate" type="text/html" title="Code snippets" /><published>2022-07-29T00:00:00-07:00</published><updated>2022-07-29T00:00:00-07:00</updated><id>http://localhost:4000/javascript/2022/07/29/Code-Snipets</id><content type="html" xml:base="http://localhost:4000/javascript/2022/07/29/Code-Snipets.html"><![CDATA[<h1 id="getelementbyid">GetElementById</h1>

<p><img src="/getElementById.png" alt="getElement" /></p>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[GetElementById]]></summary></entry><entry><title type="html">Recap</title><link href="http://localhost:4000/general/2022/07/29/html-JS-Recap.html" rel="alternate" type="text/html" title="Recap" /><published>2022-07-29T00:00:00-07:00</published><updated>2022-07-29T00:00:00-07:00</updated><id>http://localhost:4000/general/2022/07/29/html-JS-Recap</id><content type="html" xml:base="http://localhost:4000/general/2022/07/29/html-JS-Recap.html"><![CDATA[<p>###</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;a&gt;  </code> -  Renders clickable hyperlink</li>
  <li><code class="language-plaintext highlighter-rouge">&lt;ol&gt; </code></li>
  <li><code class="language-plaintext highlighter-rouge">&lt;ul&gt; </code></li>
  <li><code class="language-plaintext highlighter-rouge">&lt;li&gt; </code></li>
  <li><code class="language-plaintext highlighter-rouge">&lt;h1&gt; </code> - Through <code class="language-plaintext highlighter-rouge">&lt;h6&gt;</code></li>
  <li><code class="language-plaintext highlighter-rouge">&lt;img&gt;</code> - Renders pictures</li>
</ul>

<h3 id="forms">Forms</h3>
<ul>
  <li><code class="language-plaintext highlighter-rouge">&lt;input&gt;</code>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">type</code></li>
      <li><code class="language-plaintext highlighter-rouge">label</code></li>
      <li><code class="language-plaintext highlighter-rouge">id</code></li>
      <li><code class="language-plaintext highlighter-rouge">submit</code></li>
      <li><code class="language-plaintext highlighter-rouge">reset</code> clears the form data</li>
    </ul>
  </li>
</ul>

<h3 id="css">CSS</h3>

<ul>
  <li>Rulesets / rules
    <ul>
      <li>collections that specify elements to style and the styling to apply</li>
    </ul>
  </li>
  <li>Declarations
    <ul>
      <li>property value pairs specifying the styling</li>
    </ul>
  </li>
  <li>Selectors
    <ul>
      <li>determine which elements to apply the styling to</li>
    </ul>
  </li>
  <li>Properties
    <ul>
      <li>kind of styling we are applying</li>
    </ul>
  </li>
  <li>
    <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">p</span><span class="p">{</span>
<span class="nl">background-color</span><span class="p">:</span> <span class="no">green</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
    <h3 id="selectors">Selectors</h3>
  </li>
  <li>id
    <ul>
      <li>prefix by #</li>
    </ul>
  </li>
  <li>class
    <ul>
      <li>prefix by period</li>
      <li>
        <div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nc">.nameofclass</span><span class="p">{</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>tag
    <ul>
      <li>write the name of the tag itself</li>
    </ul>
  </li>
  <li>other attributes</li>
  <li></li>
  <li>combining multiple selectors</li>
  <li>```css
p.nameofclass {</li>
</ul>

<p>}</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
### where to include css

- inline
- externally
- 

### specificity
- Ruleset with the most specific selector takes precedence
- if one selects by `id` the other does not, the one with `id` takes precedence
- if there is a tie then we compare the n
- 
- 
### Box Model
- has four layers margin, border, padding, and content
- 
### sizing in hte css styles
- specify size in two ways:
    - absolutes
        - takes the same space of the window -  px cm in
    - relative
        - adapts to the size of the window in use % or em
### responsive
- implement styling
    - relative sizing in css declarations 

### Javascript
    
- loosely -typed
    - variables can be declared at run time
- dynamic
    - types 
- seven primitives
    - String
    - Number
    - BigInt
    - Null
    - Undefined
    - Symbol
    - boolean
- declarations    
    - var
        - older way prior to es6, 
        - global
            - outside function
        -  or function
            - inside function
    - const
        - for constants
        - enforces block scope
        - immutable
    - let
    - 
    - Hoisting
        - you can use var variables before assignment
        - 
    - Type coercion
        - implicit conversion of a type to another
        - 
### Control flow
- conditionals
    - if 
    - else
    - if else
- Ternary operator
    - short hand for ef else
    - `a = condition ? 'condition is true' : 'condition is false'; `

    - for of loop
        ```javascript
        for(let iterableVariable of iterableObject){
    
}
        ```
    - for in loop
    ```javascript
    for(let iterableVariable in Object){
}
    ```


### Arrays
- zero indexed
- use of square brackets
- ```javascript
let myArray = [1,2,3];

</code></pre></div></div>
<ul>
  <li>dynamically sized in js</li>
  <li>.length</li>
  <li>initialize objects through object literals</li>
  <li>
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myObject</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">firstKey</span><span class="p">:</span> <span class="dl">'</span><span class="s1">first Value</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>refer to value using the dot notation <code class="language-plaintext highlighter-rouge">.</code> , or the square brackets</li>
  <li></li>
  <li>
    <h3 id="falsey-values">Falsey Values</h3>
  </li>
  <li>null</li>
  <li>undefined</li>
  <li>0</li>
  <li>empty string</li>
  <li>NaN</li>
  <li>false
they evaluate to falsein control flow</li>
</ul>

<h3 id="functions">functions</h3>
<ul>
  <li>
    <h3 id="immediately-invoked-functions">immediately invoked functions</h3>
    <p>```javascript
(function)(){}();</p>
  </li>
</ul>

<p>(()=&gt;);</p>

<p>(()={
})();
```</p>
<h3 id="dom">DOM</h3>
<ul>
  <li>Selector methods</li>
  <li>getElementById()</li>
  <li>getElementByTagName()</li>
  <li>getElementByClassName()</li>
  <li>querySelector()
    <ul>
      <li>uses css syntax</li>
    </ul>
  </li>
  <li>querySelectorAll()</li>
  <li>
    <h3 id="event">Event</h3>
  </li>
  <li>event listeners
    <ul>
      <li>attach to elements in the js code by using addEventListener(event, handler, useCapture)</li>
      <li>event- event</li>
      <li>handler - function to invoke</li>
      <li>useCapture - determines if even fires in bubbling or capturing phases</li>
      <li>to remove eventListener
        <h3 id="event-propagation">Event Propagation</h3>
      </li>
    </ul>
  </li>
</ul>]]></content><author><name></name></author><category term="General" /><summary type="html"><![CDATA[### &lt;a&gt; - Renders clickable hyperlink &lt;ol&gt; &lt;ul&gt; &lt;li&gt; &lt;h1&gt; - Through &lt;h6&gt; &lt;img&gt; - Renders pictures]]></summary></entry><entry><title type="html">Operator Precedence</title><link href="http://localhost:4000/javascript/2022/07/28/JavaScript-Operators.html" rel="alternate" type="text/html" title="Operator Precedence" /><published>2022-07-28T18:06:00-07:00</published><updated>2022-07-28T18:06:00-07:00</updated><id>http://localhost:4000/javascript/2022/07/28/JavaScript-Operators</id><content type="html" xml:base="http://localhost:4000/javascript/2022/07/28/JavaScript-Operators.html"><![CDATA[<ul>
  <li>Operators are special functions</li>
  <li>infix means the operator sits in between the parameters</li>
</ul>

<table class="fullwidth-table">
  <tbody>
    <tr>
      <th>Precedence</th>
      <th>Operator type</th>
      <th>Associativity</th>
      <th>Individual operators</th>
    </tr>
    <tr>
      <td>18 Highest</td>
      <td>
        
      </td>
      <td>n/a</td>
      <td><code>( … )</code></td>
    </tr>
    <tr>
      <td rowspan="5">17</td>
      <td>
        
      </td>
      <td>left-to-right</td>
      <td><code>… . …</code></td>
    </tr>
    <tr>
      <td>
        
      </td>
      <td>n/a</td>
      <td><code>… [ … ]</code></td>
    </tr>
    <tr>
      <td> (with argument list)</td>
      <td>n/a</td>
      <td><code>new … ( … )</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Guide/Functions">Function Call</a>
      </td>
      <td>n/a</td>
      <td>
        <code>… ( … )</code>
      </td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining">Optional chaining</a>
      </td>
      <td>left-to-right</td>
      <td><code>?.</code></td>
    </tr>
    <tr>
      <td>16</td>
      <td>
         (without argument list)
      </td>
      <td>n/a</td>
      <td><code>new …</code></td>
    </tr>
    <tr>
      <td rowspan="2">15</td>
      <td>
        
      </td>
      <td rowspan="2">n/a</td>
      <td><code>… ++</code></td>
    </tr>
    <tr>
      <td>
        
      </td>
      <td><code>… --</code></td>
    </tr>
    <tr>
      <td rowspan="10">14</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT">Logical NOT (!)</a>
      </td>
      <td rowspan="10">n/a</td>
      <td><code>! …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_NOT">Bitwise NOT (~)</a>
      </td>
      <td><code>~ …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Unary_plus">Unary plus (+)</a>
      </td>
      <td><code>+ …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Unary_negation">Unary negation (-)</a>
      </td>
      <td><code>- …</code></td>
    </tr>
    <tr>
      <td>
        
      </td>
      <td><code>++ …</code></td>
    </tr>
    <tr>
      <td>
        
      </td>
      <td><code>-- …</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>typeof …</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>void …</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>delete …</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>await …</code></td>
    </tr>
    <tr>
      <td>13</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Exponentiation">Exponentiation (**)</a>
      </td>
      <td>right-to-left</td>
      <td><code>… ** …</code></td>
    </tr>
    <tr>
      <td rowspan="3">12</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Multiplication">Multiplication (*)</a>
      </td>
      <td rowspan="3">left-to-right</td>
      <td><code>… * …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Division">Division (/)</a>
      </td>
      <td><code>… / …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Remainder">Remainder (%)</a>
      </td>
      <td><code>… % …</code></td>
    </tr>
    <tr>
      <td rowspan="2">11</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Addition">Addition (+)</a>
      </td>
      <td rowspan="2">left-to-right</td>
      <td><code>… + …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Subtraction">Subtraction (-)</a>
      </td>
      <td><code>… - …</code></td>
    </tr>
    <tr>
      <td rowspan="3">10</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Left_shift">Bitwise Left Shift (&#x3C;&#x3C;)</a>
      </td>
      <td rowspan="3">left-to-right</td>
      <td><code>… &#x3C;&#x3C; …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Right_shift">Bitwise Right Shift (&gt;&gt;)</a>
      </td>
      <td><code>… &gt;&gt; …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned_right_shift">Bitwise Unsigned Right Shift (&gt;&gt;&gt;)</a>
      </td>
      <td><code>… &gt;&gt;&gt; …</code></td>
    </tr>
    <tr>
      <td rowspan="6">9</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Less_than">Less Than (&#x3C;)</a>
      </td>
      <td rowspan="6">left-to-right</td>
      <td><code>… &#x3C; …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Less_than_or_equal">Less Than Or Equal (&#x3C;=)</a>
      </td>
      <td><code>… &#x3C;= …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Greater_than">Greater Than (&gt;)</a>
      </td>
      <td><code>… &gt; …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Greater_than_or_equal">Greater Than Or Equal (&gt;=)</a>
      </td>
      <td><code>… &gt;= …</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>… in …</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>… instanceof …</code></td>
    </tr>
    <tr>
      <td rowspan="4">8</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Equality">Equality (==)</a>
      </td>
      <td rowspan="4">left-to-right</td>
      <td><code>… == …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Inequality">Inequality (!=)</a>
      </td>
      <td><code>… != …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Strict_equality">Strict Equality (===)</a>
      </td>
      <td><code>… === …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Strict_inequality">Strict Inequality (!==)</a>
      </td>
      <td><code>… !== …</code></td>
    </tr>
    <tr>
      <td>7</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_AND">Bitwise AND (&#x26;)</a>
      </td>
      <td>left-to-right</td>
      <td><code>… &#x26; …</code></td>
    </tr>
    <tr>
      <td>6</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_XOR">Bitwise XOR (^)</a>
      </td>
      <td>left-to-right</td>
      <td><code>… ^ …</code></td>
    </tr>
    <tr>
      <td>5</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR">Bitwise OR (|)</a>
      </td>
      <td>left-to-right</td>
      <td><code>… | …</code></td>
    </tr>
    <tr>
      <td>4</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND">Logical AND (&#x26;&#x26;)</a>
      </td>
      <td>left-to-right</td>
      <td><code>… &#x26;&#x26; …</code></td>
    </tr>
    <tr>
      <td rowspan="2">3</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR">Logical OR (||)</a>
      </td>
      <td>left-to-right</td>
      <td><code>… || …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator">Nullish coalescing operator (??)</a>
      </td>
      <td>left-to-right</td>
      <td><code>… ?? …</code></td>
    </tr>
    <tr>
      <td rowspan="21">2</td>
      <td rowspan="16">
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators#assignment_operators">Assignment</a>
      </td>
      <td rowspan="16">right-to-left</td>
      <td><code>… = …</code></td>
    </tr>
    <tr>
      <td><code>… += …</code></td>
    </tr>
    <tr>
      <td><code>… -= …</code></td>
    </tr>
    <tr>
      <td><code>… **= …</code></td>
    </tr>
    <tr>
      <td><code>… *= …</code></td>
    </tr>
    <tr>
      <td><code>… /= …</code></td>
    </tr>
    <tr>
      <td><code>… %= …</code></td>
    </tr>
    <tr>
      <td><code>… &#x3C;&#x3C;= …</code></td>
    </tr>
    <tr>
      <td><code>… &gt;&gt;= …</code></td>
    </tr>
    <tr>
      <td><code>… &gt;&gt;&gt;= …</code></td>
    </tr>
    <tr>
      <td><code>… &#x26;= …</code></td>
    </tr>
    <tr>
      <td><code>… ^= …</code></td>
    </tr>
    <tr>
      <td><code>… |= …</code></td>
    </tr>
    <tr>
      <td><code>… &#x26;&#x26;= …</code></td>
    </tr>
    <tr>
      <td><code>… ||= …</code></td>
    </tr>
    <tr>
      <td><code>… ??= …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">Conditional (ternary) operator</a>
      </td>
      <td>right-to-left<br />(Groups on expressions after <code>?</code>)</td>
      <td><code>… ? … : …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow (=&gt;)</a>
      </td>
      <td rowspan="4">n/a</td>
      <td><code>… =&gt; …</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>yield …</code></td>
    </tr>
    <tr>
      <td></td>
      <td><code>yield* …</code></td>
    </tr>
    <tr>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax">Spread (...)</a>
      </td>
      <td><code>... …</code></td>
    </tr>
    <tr>
      <td>1</td>
      <td>
        <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator">Comma / Sequence</a>
      </td>
      <td>left-to-right</td>
      <td><code>… , …</code></td>
    </tr>
  </tbody>
</table>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[Operators are special functions infix means the operator sits in between the parameters]]></summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2022/07/28/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2022-07-28T16:30:13-07:00</published><updated>2022-07-28T16:30:13-07:00</updated><id>http://localhost:4000/jekyll/update/2022/07/28/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2022/07/28/welcome-to-jekyll.html"><![CDATA[<p>You’ll find this post in your <code class="language-plaintext highlighter-rouge">_posts</code> directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run <code class="language-plaintext highlighter-rouge">jekyll serve</code>, which launches a web server and auto-regenerates your site when a file is updated.</p>

<p>Jekyll requires blog post files to be named according to the following format:</p>

<p><code class="language-plaintext highlighter-rouge">YEAR-MONTH-DAY-title.MARKUP</code></p>

<p>Where <code class="language-plaintext highlighter-rouge">YEAR</code> is a four-digit number, <code class="language-plaintext highlighter-rouge">MONTH</code> and <code class="language-plaintext highlighter-rouge">DAY</code> are both two-digit numbers, and <code class="language-plaintext highlighter-rouge">MARKUP</code> is the file extension representing the format used in the file. After that, include the necessary front matter. Take a look at the source for this post to get an idea about how it works.</p>

<p>Jekyll also offers powerful support for code snippets:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">print_hi</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"Hi, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">print_hi</span><span class="p">(</span><span class="s1">'Tom'</span><span class="p">)</span>
<span class="c1">#=&gt; prints 'Hi, Tom' to STDOUT.</span></code></pre></figure>

<p>Check out the <a href="https://jekyllrb.com/docs/home">Jekyll docs</a> for more info on how to get the most out of Jekyll. File all bugs/feature requests at <a href="https://github.com/jekyll/jekyll">Jekyll’s GitHub repo</a>. If you have questions, you can ask them on <a href="https://talk.jekyllrb.com/">Jekyll Talk</a>.</p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.]]></summary></entry><entry><title type="html">Intro</title><link href="http://localhost:4000/javascript/2022/07/28/Javascript-Intro.html" rel="alternate" type="text/html" title="Intro" /><published>2022-07-28T16:30:13-07:00</published><updated>2022-07-28T16:30:13-07:00</updated><id>http://localhost:4000/javascript/2022/07/28/Javascript-Intro</id><content type="html" xml:base="http://localhost:4000/javascript/2022/07/28/Javascript-Intro.html"><![CDATA[<h3 id="intro">Intro</h3>
<ul>
  <li>Javascript is an interpret language that web browsers can parse and execute.</li>
  <li>It is  single threaded ; meaning that JavaScript engines will run and execute code one process at a time.</li>
  <li>It is multi-paradigm ; meaning that it can be
    <ul>
      <li>functional</li>
      <li>object oriented</li>
      <li>or procedural</li>
    </ul>
  </li>
  <li>It is loosely typed and dynamically typed:
    <ul>
      <li>No need to declare type when declaring the variables</li>
      <li>The variable types are declared at runtime.</li>
    </ul>
  </li>
</ul>

<h3 id="data-types">Data Types</h3>

<ul>
  <li>Number</li>
  <li>String</li>
  <li>Boolean</li>
  <li>Undefined</li>
  <li>Symbol</li>
  <li>Null</li>
  <li>BigInt</li>
  <li>Primitive type represents a  unit value</li>
</ul>

<h3 id="variable-declarations">Variable Declarations</h3>

<ul>
  <li><code class="language-plaintext highlighter-rouge">var</code> - hoisted</li>
  <li><code class="language-plaintext highlighter-rouge">let</code> - not hoisted</li>
  <li><code class="language-plaintext highlighter-rouge">const</code> - not hoisted</li>
  <li>
    <h3 id="hoisting">Hoisting</h3>
  </li>
</ul>

<h3 id="type-coercion">Type Coercion</h3>

<ul>
  <li>Implicit conversion of the variable from one data type to another</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>Value</td>
      <td>Becomes…</td>
    </tr>
    <tr>
      <td><strong>__</strong></td>
      <td><strong>__</strong>_____</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">Undefined</code></td>
      <td><code class="language-plaintext highlighter-rouge">Nan</code></td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">null</code></td>
      <td>0</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">true</code></td>
      <td>1</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">false</code></td>
      <td>0</td>
    </tr>
    <tr>
      <td>String</td>
      <td>white space from the start and end of the string are removed. string with empty values are converted to 0. If possible, a string will be converted to number, else it will be converted to <code class="language-plaintext highlighter-rouge">NaN</code></td>
    </tr>
  </tbody>
</table>

<ul>
  <li>If one of the values is a String and the operator is <code class="language-plaintext highlighter-rouge">+</code>, the other value will be converted to a string as well.</li>
  <li>Using <code class="language-plaintext highlighter-rouge">==</code> to compare two entities? Javascript will try tio convert both to numbers.</li>
  <li>To check equality without type coercion, use the <code class="language-plaintext highlighter-rouge">===</code></li>
  <li>In the case of two libraries with the same names that are being imported, check if there is aready a library with the names and if not load the one of your choice</li>
  <li>
    <div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">libraryName</span> <span class="o">=</span> <span class="nb">window</span><span class="p">.</span><span class="nx">libraryName</span> <span class="o">||</span> <span class="dl">"</span><span class="s2">lib2</span><span class="dl">"</span><span class="p">;</span>
</code></pre></div>    </div>
  </li>
</ul>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[Intro Javascript is an interpret language that web browsers can parse and execute. It is single threaded ; meaning that JavaScript engines will run and execute code one process at a time. It is multi-paradigm ; meaning that it can be functional object oriented or procedural It is loosely typed and dynamically typed: No need to declare type when declaring the variables The variable types are declared at runtime.]]></summary></entry><entry><title type="html">Asynchronous</title><link href="http://localhost:4000/javascript/2022/07/28/Asynchronous.html" rel="alternate" type="text/html" title="Asynchronous" /><published>2022-07-28T00:00:00-07:00</published><updated>2022-07-28T00:00:00-07:00</updated><id>http://localhost:4000/javascript/2022/07/28/Asynchronous</id><content type="html" xml:base="http://localhost:4000/javascript/2022/07/28/Asynchronous.html"><![CDATA[<h3 id="asynchronous">Asynchronous</h3>
<p>what is asynchronous in javascript?</p>
<ul>
  <li>In javascript there is the execution stack and the event cue, as soon as the execution task is empty, the event queue is entered</li>
</ul>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">waitFourSecs</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">ms</span> <span class="o">=</span> <span class="mi">4000</span> <span class="o">+</span> <span class="k">new</span> <span class="nb">Date</span><span class="p">().</span><span class="nx">getTime</span><span class="p">();</span>
    <span class="k">while</span><span class="p">(</span><span class="k">new</span> <span class="nb">Date</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nx">ms</span> <span class="p">){}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">finished function</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">clickHandler</span><span class="p">(){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">click event!</span><span class="dl">'</span><span class="p">);</span>

<span class="p">}</span>

<span class="nb">document</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span><span class="nx">clickHandler</span><span class="p">);</span>

<span class="nx">waitFourSecs</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">finished execution</span><span class="dl">'</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>The click even above will be executed last</li>
</ul>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[Asynchronous what is asynchronous in javascript? In javascript there is the execution stack and the event cue, as soon as the execution task is empty, the event queue is entered]]></summary></entry><entry><title type="html">Control Flow</title><link href="http://localhost:4000/javascript/2022/07/28/Control-Flow.html" rel="alternate" type="text/html" title="Control Flow" /><published>2022-07-28T00:00:00-07:00</published><updated>2022-07-28T00:00:00-07:00</updated><id>http://localhost:4000/javascript/2022/07/28/Control-Flow</id><content type="html" xml:base="http://localhost:4000/javascript/2022/07/28/Control-Flow.html"><![CDATA[]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Keyword This</title><link href="http://localhost:4000/javascript/2018/12/14/KeyWordThis.html" rel="alternate" type="text/html" title="Keyword This" /><published>2018-12-14T00:00:00-08:00</published><updated>2018-12-14T00:00:00-08:00</updated><id>http://localhost:4000/javascript/2018/12/14/KeyWordThis</id><content type="html" xml:base="http://localhost:4000/javascript/2018/12/14/KeyWordThis.html"><![CDATA[<p>when a function is invoked a new execution context is created
Remember not to confuse this with the object that we’ve been discussing.
The object sitting in memory that is a function has properties and methods.
It has a name property and a code property where the code lives.
But when that code is invoked and
execution context is created and put on the execution stack.
And that determines how that code is Run, is executed.
So think of the execution context
as focusing on that code portion of that function object.
What happens when I run the code in that code property?
So we know that an execution context is created.
Each executions context has this variable environment.
Where the variables created inside that function live.
It has a reference to its outer environment.
Its outer lexical environment, where it sits physically in the code,
which tells it how to look down the scope chain.
In other words, if I ask for a variable and
it’s not there inside that function’s variable environment.
It’ll go out and out further, and all the way out until it reaches the global
environment looking for that variable or that function.
So it has that outer reference.
And we also know that in JavaScript engine every time
an execution context is created, that is every time a function is Run.
It gives us, without us having to create it, declare it or
anything, it gives us this variable called this, which can be useful.
And this will be pointing at a different object,
a different thing, depending on how the function is invoked.
This can cause a lot of confusion.
There are a few scenarios where this
will be changed depending on how the function is called.
For the JavaScript engine will decide that this should point to something different.
That the this keyword is a particular object or another,
depending on where the function is and how it’s called.
So let’s take a look at a couple of these scenarios, and
we’ll see this again later in the course as well.
So, the this keyword.
I once again have my empty app.js file, and
we’ll use some simple examples to explain what this,
the keyword this will be under certain circumstances.
Now you maybe thinking that you’d like to see some more concrete complete examples.
I agree.
As this course goes on especially toward the end, we’ll look at far more complex
examples of the concepts that we’re using in the real world and
in very popular JavaScript libraries and frameworks.
But I believe it’s important first to understand the concept and
not get bogged down in the details of implementation of more complex examples.
So right now we’re focusing on just
understanding what’s happening under the hood with JavaScript.
And then later we’ll build on that knowledge with more complex example.
For now, let’s move on talking about this keyword.
We’ve already seen that this is immediately available, the keyword this.
Even at the global execution context level.
So I can run this, and inside the browser, it’s going to show me the window object.
Because this points to the global object at this level in the code.
And inside the browser, the global object is,
as you might recall, the Window object.
Now let’s look at another example, let’s say I have a function.
I’ll just call it a, and I’m going to log this.
And then, I’ll invoke a.
Remember that invoking a, means run that code property
which contains all the lines of code inside the function.
And the first thing it does is create that execution context, and one of that
pieces of the puzzle is the creation of the keyword this.
So what will the keyword this be
inside the execution context that’s created by invoking a?
Execution context for running the a function.
Now let’s take a look.
It’s also the Window object.
So when you create a function, the this keyword is still going to
point to the global object.
If you decided to use this, if you’re simply invoking the function.
Similarly, if I use a function expression
to set up the object, and then set that equal to a variable.
Actually I mean this.
So, var b gets this function expression to declare it, to create it.
What will this be in that case?
Well, I’ll go ahead and
invoke b, using the variable name to point to that function.
And it’s still Window.
So whenever I create a function
that’s simply a function expression or a function statement.
Creating a function at this level in the code,
then this will point to the global object.
And that’s true even though there’s actually
three execution contexts that we see here.
The global one, then the one that’s created when a is invoked, and
another execution context that’s created when b is invoked.
And in each of those cases, they get their own this keyword.
But in all those cases, the keyword points to the same address,
the same location in your computer’s memory.
So they’re all pointing at the global object.
Makes sense?
That means you could even do strange things like this.newvariable
let’s say equals hello.
I’ve attached it to the global object.
So after I call a, I could actually console.log newvariable.
Cuz that’s been created and using the dot operator,
I’ve attached a new variable to the global object.
And remember,
any variables attached to the global object, I can just reference like that.
I don’t need to use the dot operator.
It just assumes I’m asking for a variable on the global object.
So I can refresh this and
actually see that hello, kind of strange.
If you don’t understand what this keyword is pointing to and
you think you’re somehow attaching this to the function, you’re not.
You’re actually crashing into the global namespace and
you could cause yourself a lot of problems.
So when you’re just invoking the function, this points to the global variable.
However, you may have seen something that looks like this when learning JavaScript.
We’re gonna talk about that later in the course about what circumstance
when you would use the this variable inside a function like this.
Now that said, what about an object method?
Let me create a little space here and I’ll create a new object literal and
now that we understand function expressions,
I can do something that we haven’t done before inside an object literal.
I can create a method.
Remember, if the value is a primitive, it’s called a property.
And if the value a function, it’s called a method.
So, I’ll create a name-value pair.
I’ll just call it name, so we can recognize the object and
I’ll call it the c object and then a comma and I’ll create a method.
I’ll do log: so that’s the name and
then the value I want to create a function object.
So, I’ll just use a function expression.
An anonymous function, no name and
then I’ll console.log this and
then I’ll call c.log So
now I can invoke the function that was created inside this object literal,
which is attached to this log.
So this is the log method of the object c.
See that?
What will this turn out to be?
Remember every time a function is invoked, a new execution context is created and
the JavaScript engine decides what that keyword,
the keyword this should be pointing to.
In these other cases, it was the window object.
But in this case, it’s a method on an object and
that means, see that there at the bottom?
In the case where a function is actually a method
attached to an object, this keyword becomes
the object that that method is sitting inside of c.
See that?
These functions, this keyword.
The JavaScript engine said, you’re attached to an object.
So when you see, when you use the this keyword I’m going to
be pointing at that very object that contains you.
So I could actually say,
this.name = ‘Updated c object’
And then when this is logged, see that?
I changed that property on this parent object,
the object that holds the function.
So that’s useful.
I can mutate that is change the object,
that contains me if I’m a method of that object by using of this keyword.
You can imagine that can be very useful to be able to access other properties and
methods on the same object that a particular method lives on.
This is very common to use and it’s neat.
Now there’s one more thing to show you and
this a lot of people feel is a bug in JavaScript.
Now you might be saying, what do you mean a bug in JavaScript?
Well, JavaScript is a programming language and the engines and the language was
designed by people and so decisions were made about how things should work.
And in this one case, this decision a lot of people feel is wrong.
Let me show you.
Let’s suppose that I create a function inside this method, we can do that right.
I’m gonna call it setname, I’ll use a variable and
I’ll set a function expression.
This time, I’ll pass a variable to my function.
Let’s say, new name.
I can do that.
And inside here, I’m gonna say this.name = newname.
So, I’m trying to update or
mutate my object with this newname.
And then let’s say that here,
I’m going to go ahead and call setname and
I’ll say ‘Updated again!
The c object’) and
then console.log(this) again.
So I mutate it and I should see ‘Updated c object’.
I create a function that also, well when executed, create a new execution context.
And I would expect, personally that this keyword would
still point to the containing object,
because it’s a function inside of a function, inside of an object.
And since this keyword points to the object, I would expect, well, one more
function down and it’ll still point to the object and I can mutate it, change it.
So I would expect that after calling this setname function,
I’ll see updated again the c object as the name on that second console.log.
Let’s try it.
Well, that’s a problem.
“Updated c object” and Updated c object”.
Meaning, this ran, but
this didn’t seem to do anything or did it.
Oh, let’s try going back and taking a look
at the window object, the global object.
And if I take a good look, look at that.
See that?
That name property here was instead created and
added by the equals operator on the global object.
That means that this internal function, when its execution
context was created, the this key word points to the global object,
even though it’s sitting kind of inside an object that I created.
I think that’s wrong and a lot of people do, but
that’s the way JavaScript works in this case and
there’s not a lot we can do about it at this point.
So what can we do when I have this kind of scenario?
To make sure that I’m using the right object.
That this keyword isn’t causing me to make an unintended error.
Well there’s a very common pattern that we can use in this case.
And we’ll understand it because We understand
that objects are set by reference.
Now that we understand that, we can understand this pattern.
I can simply say I’m going to set a variable.
I’ll call it self.
Some people call it that, but I like self.
Because I’m inside this object.
And I’m going to set that equal to this.
It was the very first line of my object method.
So what happened right here?
Well, now we have a new variable called self, and
since these are objects, it’s going to be set equal to by reference.
So self will be pointing at the same location in memory as the this keyword.
And right now, the this keyword on this line of code is pointing to
my whole object.
And then for sanity’s sake, we simply use self everywhere where we normally
would have used this, even inside these sub-functions.
That way I don’t have to think about, am I pointing to the right object?
This is still pointing.
The self variable is still pointing to the same location in memory as this.
So when I mutate it, when I change it, when I add something to it or change it or
whatever, it’s going to update the appropriate thing,
in this case, my whole object.
So self, I can log that, and then when I look
at this new function that I created, and this gets executed right here.
I don’t even worry about the this variable.
I simply say self.
So what’s going to happen?
Well, self isn’t declared inside this function.
So the JavaScript engine will look down the scope chain.
Where is this function sitting physically in the code?
Well, right inside here.
So we can see that’ll it just go outside to the next area outside, the outer
lexical reference, and look for it, a variable called self and it will find it.
And so this right here, the self variable inside this function,
will end up being this one here.
And that’s still pointing to my whole object.
So I can mutate my object here, as well.
So now, this should show up properly.
I have a proper reference to my object.
And then I just use it from there on out, just for sanity’s sake, so
I don’t have to think about it.
And then I’ll mutate it, I’ll change it.
And then I’ll create a function, and
I’ll call that function and that will mutate the object.
And I’ll put it again.
So this time I should see, look at that.
That’s proper.
That’s what I expected.
So what did we learn?
We learned that no programming language is perfect.
They all have their quirks, and JavaScript certainly isn’t an exception.
But there are patterns we can use to get around
any problems the programming language might have.
Now I also wanna make mention that this pattern you’ll see very often if
you’re working in any real-world JavaScript scenarios.
However, the let keyword, which will be an alternative
to the var keyword, is meant to clear some of these problems up.
So as that becomes available in modern browsers,
and depending on the kind of project you’re working on,
if you’re working on a web project and you don’t have to worry about older browsers.
That’s something that you’ll soon start to be able to use,
and bonus lectures in this course will help with that, as time goes on.
But for now, realize that this pattern is a good one.
It is used quite often and is quite useful.
So we’ve seen the this key word.
It’s the global variable, or
the global object, when just invoking a function like this.
And when the function is a method of an object,
the this keyword points to the object.
However, any internal functions have a problem.
So we can use this concept of setting a variable equal to this,
and then just carrying that with us the rest of the way to
make sure that we don’t run across any unintentional errors,
or somehow throw things onto the global object that we didn’t mean to.
All right, let’s move on.</p>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[when a function is invoked a new execution context is created Remember not to confuse this with the object that we’ve been discussing. The object sitting in memory that is a function has properties and methods. It has a name property and a code property where the code lives. But when that code is invoked and execution context is created and put on the execution stack. And that determines how that code is Run, is executed. So think of the execution context as focusing on that code portion of that function object. What happens when I run the code in that code property? So we know that an execution context is created. Each executions context has this variable environment. Where the variables created inside that function live. It has a reference to its outer environment. Its outer lexical environment, where it sits physically in the code, which tells it how to look down the scope chain. In other words, if I ask for a variable and it’s not there inside that function’s variable environment. It’ll go out and out further, and all the way out until it reaches the global environment looking for that variable or that function. So it has that outer reference. And we also know that in JavaScript engine every time an execution context is created, that is every time a function is Run. It gives us, without us having to create it, declare it or anything, it gives us this variable called this, which can be useful. And this will be pointing at a different object, a different thing, depending on how the function is invoked. This can cause a lot of confusion. There are a few scenarios where this will be changed depending on how the function is called. For the JavaScript engine will decide that this should point to something different. That the this keyword is a particular object or another, depending on where the function is and how it’s called. So let’s take a look at a couple of these scenarios, and we’ll see this again later in the course as well. So, the this keyword. I once again have my empty app.js file, and we’ll use some simple examples to explain what this, the keyword this will be under certain circumstances. Now you maybe thinking that you’d like to see some more concrete complete examples. I agree. As this course goes on especially toward the end, we’ll look at far more complex examples of the concepts that we’re using in the real world and in very popular JavaScript libraries and frameworks. But I believe it’s important first to understand the concept and not get bogged down in the details of implementation of more complex examples. So right now we’re focusing on just understanding what’s happening under the hood with JavaScript. And then later we’ll build on that knowledge with more complex example. For now, let’s move on talking about this keyword. We’ve already seen that this is immediately available, the keyword this. Even at the global execution context level. So I can run this, and inside the browser, it’s going to show me the window object. Because this points to the global object at this level in the code. And inside the browser, the global object is, as you might recall, the Window object. Now let’s look at another example, let’s say I have a function. I’ll just call it a, and I’m going to log this. And then, I’ll invoke a. Remember that invoking a, means run that code property which contains all the lines of code inside the function. And the first thing it does is create that execution context, and one of that pieces of the puzzle is the creation of the keyword this. So what will the keyword this be inside the execution context that’s created by invoking a? Execution context for running the a function. Now let’s take a look. It’s also the Window object. So when you create a function, the this keyword is still going to point to the global object. If you decided to use this, if you’re simply invoking the function. Similarly, if I use a function expression to set up the object, and then set that equal to a variable. Actually I mean this. So, var b gets this function expression to declare it, to create it. What will this be in that case? Well, I’ll go ahead and invoke b, using the variable name to point to that function. And it’s still Window. So whenever I create a function that’s simply a function expression or a function statement. Creating a function at this level in the code, then this will point to the global object. And that’s true even though there’s actually three execution contexts that we see here. The global one, then the one that’s created when a is invoked, and another execution context that’s created when b is invoked. And in each of those cases, they get their own this keyword. But in all those cases, the keyword points to the same address, the same location in your computer’s memory. So they’re all pointing at the global object. Makes sense? That means you could even do strange things like this.newvariable let’s say equals hello. I’ve attached it to the global object. So after I call a, I could actually console.log newvariable. Cuz that’s been created and using the dot operator, I’ve attached a new variable to the global object. And remember, any variables attached to the global object, I can just reference like that. I don’t need to use the dot operator. It just assumes I’m asking for a variable on the global object. So I can refresh this and actually see that hello, kind of strange. If you don’t understand what this keyword is pointing to and you think you’re somehow attaching this to the function, you’re not. You’re actually crashing into the global namespace and you could cause yourself a lot of problems. So when you’re just invoking the function, this points to the global variable. However, you may have seen something that looks like this when learning JavaScript. We’re gonna talk about that later in the course about what circumstance when you would use the this variable inside a function like this. Now that said, what about an object method? Let me create a little space here and I’ll create a new object literal and now that we understand function expressions, I can do something that we haven’t done before inside an object literal. I can create a method. Remember, if the value is a primitive, it’s called a property. And if the value a function, it’s called a method. So, I’ll create a name-value pair. I’ll just call it name, so we can recognize the object and I’ll call it the c object and then a comma and I’ll create a method. I’ll do log: so that’s the name and then the value I want to create a function object. So, I’ll just use a function expression. An anonymous function, no name and then I’ll console.log this and then I’ll call c.log So now I can invoke the function that was created inside this object literal, which is attached to this log. So this is the log method of the object c. See that? What will this turn out to be? Remember every time a function is invoked, a new execution context is created and the JavaScript engine decides what that keyword, the keyword this should be pointing to. In these other cases, it was the window object. But in this case, it’s a method on an object and that means, see that there at the bottom? In the case where a function is actually a method attached to an object, this keyword becomes the object that that method is sitting inside of c. See that? These functions, this keyword. The JavaScript engine said, you’re attached to an object. So when you see, when you use the this keyword I’m going to be pointing at that very object that contains you. So I could actually say, this.name = ‘Updated c object’ And then when this is logged, see that? I changed that property on this parent object, the object that holds the function. So that’s useful. I can mutate that is change the object, that contains me if I’m a method of that object by using of this keyword. You can imagine that can be very useful to be able to access other properties and methods on the same object that a particular method lives on. This is very common to use and it’s neat. Now there’s one more thing to show you and this a lot of people feel is a bug in JavaScript. Now you might be saying, what do you mean a bug in JavaScript? Well, JavaScript is a programming language and the engines and the language was designed by people and so decisions were made about how things should work. And in this one case, this decision a lot of people feel is wrong. Let me show you. Let’s suppose that I create a function inside this method, we can do that right. I’m gonna call it setname, I’ll use a variable and I’ll set a function expression. This time, I’ll pass a variable to my function. Let’s say, new name. I can do that. And inside here, I’m gonna say this.name = newname. So, I’m trying to update or mutate my object with this newname. And then let’s say that here, I’m going to go ahead and call setname and I’ll say ‘Updated again! The c object’) and then console.log(this) again. So I mutate it and I should see ‘Updated c object’. I create a function that also, well when executed, create a new execution context. And I would expect, personally that this keyword would still point to the containing object, because it’s a function inside of a function, inside of an object. And since this keyword points to the object, I would expect, well, one more function down and it’ll still point to the object and I can mutate it, change it. So I would expect that after calling this setname function, I’ll see updated again the c object as the name on that second console.log. Let’s try it. Well, that’s a problem. “Updated c object” and Updated c object”. Meaning, this ran, but this didn’t seem to do anything or did it. Oh, let’s try going back and taking a look at the window object, the global object. And if I take a good look, look at that. See that? That name property here was instead created and added by the equals operator on the global object. That means that this internal function, when its execution context was created, the this key word points to the global object, even though it’s sitting kind of inside an object that I created. I think that’s wrong and a lot of people do, but that’s the way JavaScript works in this case and there’s not a lot we can do about it at this point. So what can we do when I have this kind of scenario? To make sure that I’m using the right object. That this keyword isn’t causing me to make an unintended error. Well there’s a very common pattern that we can use in this case. And we’ll understand it because We understand that objects are set by reference. Now that we understand that, we can understand this pattern. I can simply say I’m going to set a variable. I’ll call it self. Some people call it that, but I like self. Because I’m inside this object. And I’m going to set that equal to this. It was the very first line of my object method. So what happened right here? Well, now we have a new variable called self, and since these are objects, it’s going to be set equal to by reference. So self will be pointing at the same location in memory as the this keyword. And right now, the this keyword on this line of code is pointing to my whole object. And then for sanity’s sake, we simply use self everywhere where we normally would have used this, even inside these sub-functions. That way I don’t have to think about, am I pointing to the right object? This is still pointing. The self variable is still pointing to the same location in memory as this. So when I mutate it, when I change it, when I add something to it or change it or whatever, it’s going to update the appropriate thing, in this case, my whole object. So self, I can log that, and then when I look at this new function that I created, and this gets executed right here. I don’t even worry about the this variable. I simply say self. So what’s going to happen? Well, self isn’t declared inside this function. So the JavaScript engine will look down the scope chain. Where is this function sitting physically in the code? Well, right inside here. So we can see that’ll it just go outside to the next area outside, the outer lexical reference, and look for it, a variable called self and it will find it. And so this right here, the self variable inside this function, will end up being this one here. And that’s still pointing to my whole object. So I can mutate my object here, as well. So now, this should show up properly. I have a proper reference to my object. And then I just use it from there on out, just for sanity’s sake, so I don’t have to think about it. And then I’ll mutate it, I’ll change it. And then I’ll create a function, and I’ll call that function and that will mutate the object. And I’ll put it again. So this time I should see, look at that. That’s proper. That’s what I expected. So what did we learn? We learned that no programming language is perfect. They all have their quirks, and JavaScript certainly isn’t an exception. But there are patterns we can use to get around any problems the programming language might have. Now I also wanna make mention that this pattern you’ll see very often if you’re working in any real-world JavaScript scenarios. However, the let keyword, which will be an alternative to the var keyword, is meant to clear some of these problems up. So as that becomes available in modern browsers, and depending on the kind of project you’re working on, if you’re working on a web project and you don’t have to worry about older browsers. That’s something that you’ll soon start to be able to use, and bonus lectures in this course will help with that, as time goes on. But for now, realize that this pattern is a good one. It is used quite often and is quite useful. So we’ve seen the this key word. It’s the global variable, or the global object, when just invoking a function like this. And when the function is a method of an object, the this keyword points to the object. However, any internal functions have a problem. So we can use this concept of setting a variable equal to this, and then just carrying that with us the rest of the way to make sure that we don’t run across any unintentional errors, or somehow throw things onto the global object that we didn’t mean to. All right, let’s move on.]]></summary></entry><entry><title type="html">Functions</title><link href="http://localhost:4000/javascript/2018/07/28/Functions.html" rel="alternate" type="text/html" title="Functions" /><published>2018-07-28T00:00:00-07:00</published><updated>2018-07-28T00:00:00-07:00</updated><id>http://localhost:4000/javascript/2018/07/28/Functions</id><content type="html" xml:base="http://localhost:4000/javascript/2018/07/28/Functions.html"><![CDATA[<p>Objects and Functions.</p>

<p><img src="/image.PNG" alt="image" /></p>
<ul>
  <li>In Javascript Objects and functions are related in many ways.</li>
  <li>Objects are collections of name value pairs and those values can then be other collections of name value pairs.</li>
  <li>An object can have properties and methods as values, and these can be primitives like boolean, number or a string.</li>
  <li>An object could also have another object connected to it as a child, so to speak.And this is also considered a property</li>
  <li>An object can also contain functions and in those cases the function is called a method when it’s sitting on the object.</li>
  <li>It’s still a function, but it’s connected to an object and so it’s called a method.So objects have properties and methods.And these sit in memory so the object will have some sort of address in your computer’s memory.And it will have references to these different properties and methods which are also sitting in your computer’s memory.</li>
  <li>Now they may be related to the address of that base object concept, or they may not.But either way the object has references to the addresses or the space or the spots where these different properties and methods live.</li>
  <li>So think about about an object as sitting in memory, and then having reference to other things sitting in memory that are connected to it.</li>
  <li>So it knows where its different properties and methods are, that is,primitives, objects, and function that make it up</li>
</ul>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[Objects and Functions.]]></summary></entry></feed>