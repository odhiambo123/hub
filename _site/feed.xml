<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-12-15T14:05:20-08:00</updated><id>http://localhost:4000/feed.xml</id><entry><title type="html">Functions</title><link href="http://localhost:4000/2018/12/14/Functions.html" rel="alternate" type="text/html" title="Functions" /><published>2018-12-14T00:00:00-08:00</published><updated>2018-12-14T00:00:00-08:00</updated><id>http://localhost:4000/2018/12/14/Functions</id><content type="html" xml:base="http://localhost:4000/2018/12/14/Functions.html">&lt;p&gt;It’s time for a new section of this course, called Objects and Functions.In a lot of JavaScript courses,they treat these two concepts as two different subjects to teach.I think that’s a big mistake.Because while in other programming languages, objects andlanguages are two distinct things to talk about, in JavaScript,they’re very, very much related.They’re really, in many ways, the same subject.So let’s talk about objects and functions.The first subject or the first topic we’ll discuss is objects and the dot.Remember we’ve already said that objects are collections of name value pairs
and those values can then be other collections of name value pairs.
But for our purposes now,let’s look at objects from a little bit of a different perspective.Let’s think about how an object lives or resides in your computer’s memory.An object like we said is a collection of values that are given names.But, what values are we talking about?Well, an object can have properties and methods.So an object can have a primitive sitting off of it, andthat would be called a property.Remember those primitive types that we talked about, soany one of those like a Boolean or a number or a string.
An object could have another object connected to it as a child, so to speak.
And this is also considered a property.Remember we said the value could be another name value pair collection, orthat is, another object.An object can also contain functions andin those cases the function is called a method when it’s sitting on the object.So it’s still a function but it’s connected to an object.So it’s called a method.So objects have properties and methods.And these sit in memory sothe kind of core object will have some sort of address in your computer’s memory.And it will have references to these different properties andmethods which are also sitting in your computer’s memory.Now they may be related to the address of that base object concept, or they may not.But either way the object has references to the addresses or the space orthe spots where these different properties and methods live.And those addresses might look something like that.So, this may seem a bit obscure.But it’s important for things that we’re going to talk about laterthat you think about an object as sitting in memory, and then havingreferences to other things sitting in memory that are connected to it.So it knows where its different properties and methods are, that is,primitives, objects, and function that make it up.All right, so let’s look at in JavaScripthow we access those slots in memory,those properties and functions of an object.So I have and empty app.js file andI’m going to create our first object, var person.And I’m going to use the syntax equals and instead of a primitivelike a string or a number, I’m going to say new Object.Now, let me be clear.There are better ways to do this, and we’ll cover them shortly.But just for this moment, I am going to use the new Objectsyntax to create a new Object because it’s very obvious what’s going on.So I’m creating a new Object.And this is going to sit in memory.Now I’m going to add properties and methods.So, for example, I can say person, andthen I’m going to use what’s called the computed member access operator.That’s right, an operator.An operator is this.Brackets.And inside those brackets I put the nameof the value that I’m trying to locate in memory.So let’s say firstname.It doesn’t exist yet, so when I use the = Tony,it’s going to create that spot in memory, and give it that name.And this object will get a reference to the address of that location in memory.So, it will know where firstname is in memory andthat’s going to be a primitive, a string.So, it’s called a property, the firstname property.So, this is one way to set and access properties.If I go back to my PDF of JavaScriptoperator precedence, you’ll see that we have Computed Member Access.It’s very near the top.And it’s left-to-right associativity, and it’s brackets there.So this is an operator.What the operator does is it takes this Object and thisproperty or method name, and it looks for this on this Object.It actually can do quite a bit more than that, butwe’ll see that much later in the course.But, for starters this is one way, using a string to access this.So let me set lastname.Now the neat thing about this operator is that I could set a string, let’ssay firstname, and I can then use that string to accessthat property using that bracket notation or that operator.So let me first of all just log the person itself so you can see it.And then I’ll log person.I’ll use this bracket operator and I’ll pass this string,this variable that contains the string.And remember this operator will take this object and look fora property with this name.So this name is firstname so it should find it, and what should it output?Tony.So let’s go ahead and run this in the browser.And then I’ll open my console, and there I see Tony.So the Computed Member Access operator, those brackets worked.They looked at the Object as one parameter and that string as one parameter andwent out and found that property on that Object and gave me the value.Notice I also just outputted the object itself.And I can see those two properties, firstname and lastname.There’s another property, this underscore, underscore, proto, underscore, underscore.Don’t worry about that right now.But we are gonna get into that later in the course.For now, we’ll just focus on these that I’ve named, firstname and lastname.And I’ve outputted it the first name using that special operator with the brackets.So, let’s go back to our code and let’s talk about another operator,the more common operator and clearer andeasier to type operator for accessing properties and methods.Now this approach here that we just talked about,you will see sometimes in frameworks andlibraries because you can dynamically decide what property you’re trying to get.You can base it off a string.But it’s much clearer and easier to type the next one.All right, I’m going console.log the first name again.But I’m going to use a different operator, the dot operator.And it is just what it sounds like.Dot, then I can say, first name.The dot, is an operator, it’s a function.And when used after an Object like that, well,if I go back to my JavaScriptOperatorPrecedence.pdf,you’ll see it’s just second from the top, right after the parentheses for grouping.It’s left to right and it’s just a dot and it takes two parameters,the object that you’re looking at and the name of the property.Notice I don’t have to put this in quotes or something.Although that’s essentially what it’s doing.It’s taking the object and passing the stringthat represents the name of the value that you are looking for.But I don’t have to do that, that’s not a really accurate.You can’t do that.It will simply, the syntax parser will understand that after you put the dot,what you’ve actually typed will be the string that’s given to the dot.That’s just a lot faster to type.Person.firstname, and if I run this since I’m already outputting the person andfirstname again, I’ll just get the firstname again.So I refresh and there it is.You see that?So the dot operator acted exactly the same as the brackets operator here.This is Computed Member Access.And this is just called Member Access,the Member Access operator, members being members of the Object, right?Your fingers and your toes are members of your body.So these are looking for members of the Object, the pieces, the methods, andthe properties.So this went out and found this property because it’s just a string.It’s not called a method.It’s called a property.Okay, so I could console.log person.lastname.Very readable, very easy to type.And that’s what’s really happening.It went out and found that memory location,that reference by name that’s connected to that Object.And I could have set this value as well the same way.In fact remember that the other type of property you can have,as opposed to a primitive, is also another Object.So i can attach another set of names and values.Let’s says that person.address.I’m gonna make that instead of a string or a number ora Boolean, I’ll just make it another new Object.So it’s an Object sitting inside an Object andthen I can use the dot operator for example and add propertiesto my sub-object, my child object, inside of here.Now remember these are operators, so how do we know which one gets run first?Well, we go back and we see that the associativity ofthe Member Access operator is left-to-right.It has left associativity, meaning that the left most dot will get run first, getcalled first, because they’re functions, and then moving on to the right.So this one between person and address gets called first.So it says, okay, I’ll look at the person Object andlook for a property or a method that has that name.And then it finds that in memory.And this second dot operator is called and it says, okay, on that Object that I justfound in memory, I’ll look for a property or a method on that, called street.Now in this case it won’t find it but I’m setting a value soit will create it and give it that initial value.And I could just keep doing this.So I might have address.city.Let’s say New York.And state, let’s say New York.And you could see I could make this other subobject and subobjects and subobjects.And I could just keep going because it’s a left to right dot operator,left associative.And the Objects can keep containing Objects which can contain other Objectswhich can contain other Objects.So, this is very powerful.Realize that the Objects themselves and their properties andmethods are all just sitting in memory.These dots, these brackets, passing strings to them, they’re just functions.They’re just operators, a way to access that information.So now I have this Object sitting in memory.I could do a person.address.street and output that andit’ll go find it in memory running those two different operators.I could go person.address.city and it will find that.And I could on the same object just use a different operator.So I could go address using the computed, this is also left to right.If I look, it’s left to right, so I can also then just do another one.Let’s say, state.This is essentially doing the same thing.It looks at the object, finds a property ormethod called that, runs this operator first.Then the second operator, it’ll look for a state property on that.And the dot is doing the same thing.And they’re both simply accessing the same memory locations via the same names.So they’re just two different functions that are essentially doing the same thing.And I’ll refresh, and there I’m outputting my values,that are sitting in memory, using both operators.So again, Objects are name value pairs sitting in memory.They can contain other name value pairs, that is, other Objects.They can contain other properties, strings, Booleans.They can contain numbers.They can also contain functions, which are called methods.But we’re not going to quite get there yet,because there’s a couple other things we need to understand.But good enough for here.Remember that this is not the preferred way to create a new Object.We’ll get to that in just a second.And also remember that although we can use the dot orwe can use the computed, the bracket notation here for finding properties andmethods, the preferred approach is just using the dot operator.It’s very clean, it’s very clear, and it’s also easier to debug and find problems.So I always recommend that you use the dot operator unless you really need toaccess a property or properties using some kind of dynamic string.Some kind of string that can be changed, that you can look at programmatically.But to start with, always use the dot operator&lt;/p&gt;</content><author><name>David</name></author><summary type="html">It’s time for a new section of this course, called Objects and Functions.In a lot of JavaScript courses,they treat these two concepts as two different subjects to teach.I think that’s a big mistake.Because while in other programming languages, objects andlanguages are two distinct things to talk about, in JavaScript,they’re very, very much related.They’re really, in many ways, the same subject.So let’s talk about objects and functions.The first subject or the first topic we’ll discuss is objects and the dot.Remember we’ve already said that objects are collections of name value pairs and those values can then be other collections of name value pairs. But for our purposes now,let’s look at objects from a little bit of a different perspective.Let’s think about how an object lives or resides in your computer’s memory.An object like we said is a collection of values that are given names.But, what values are we talking about?Well, an object can have properties and methods.So an object can have a primitive sitting off of it, andthat would be called a property.Remember those primitive types that we talked about, soany one of those like a Boolean or a number or a string. An object could have another object connected to it as a child, so to speak. And this is also considered a property.Remember we said the value could be another name value pair collection, orthat is, another object.An object can also contain functions andin those cases the function is called a method when it’s sitting on the object.So it’s still a function but it’s connected to an object.So it’s called a method.So objects have properties and methods.And these sit in memory sothe kind of core object will have some sort of address in your computer’s memory.And it will have references to these different properties andmethods which are also sitting in your computer’s memory.Now they may be related to the address of that base object concept, or they may not.But either way the object has references to the addresses or the space orthe spots where these different properties and methods live.And those addresses might look something like that.So, this may seem a bit obscure.But it’s important for things that we’re going to talk about laterthat you think about an object as sitting in memory, and then havingreferences to other things sitting in memory that are connected to it.So it knows where its different properties and methods are, that is,primitives, objects, and function that make it up.All right, so let’s look at in JavaScripthow we access those slots in memory,those properties and functions of an object.So I have and empty app.js file andI’m going to create our first object, var person.And I’m going to use the syntax equals and instead of a primitivelike a string or a number, I’m going to say new Object.Now, let me be clear.There are better ways to do this, and we’ll cover them shortly.But just for this moment, I am going to use the new Objectsyntax to create a new Object because it’s very obvious what’s going on.So I’m creating a new Object.And this is going to sit in memory.Now I’m going to add properties and methods.So, for example, I can say person, andthen I’m going to use what’s called the computed member access operator.That’s right, an operator.An operator is this.Brackets.And inside those brackets I put the nameof the value that I’m trying to locate in memory.So let’s say firstname.It doesn’t exist yet, so when I use the = Tony,it’s going to create that spot in memory, and give it that name.And this object will get a reference to the address of that location in memory.So, it will know where firstname is in memory andthat’s going to be a primitive, a string.So, it’s called a property, the firstname property.So, this is one way to set and access properties.If I go back to my PDF of JavaScriptoperator precedence, you’ll see that we have Computed Member Access.It’s very near the top.And it’s left-to-right associativity, and it’s brackets there.So this is an operator.What the operator does is it takes this Object and thisproperty or method name, and it looks for this on this Object.It actually can do quite a bit more than that, butwe’ll see that much later in the course.But, for starters this is one way, using a string to access this.So let me set lastname.Now the neat thing about this operator is that I could set a string, let’ssay firstname, and I can then use that string to accessthat property using that bracket notation or that operator.So let me first of all just log the person itself so you can see it.And then I’ll log person.I’ll use this bracket operator and I’ll pass this string,this variable that contains the string.And remember this operator will take this object and look fora property with this name.So this name is firstname so it should find it, and what should it output?Tony.So let’s go ahead and run this in the browser.And then I’ll open my console, and there I see Tony.So the Computed Member Access operator, those brackets worked.They looked at the Object as one parameter and that string as one parameter andwent out and found that property on that Object and gave me the value.Notice I also just outputted the object itself.And I can see those two properties, firstname and lastname.There’s another property, this underscore, underscore, proto, underscore, underscore.Don’t worry about that right now.But we are gonna get into that later in the course.For now, we’ll just focus on these that I’ve named, firstname and lastname.And I’ve outputted it the first name using that special operator with the brackets.So, let’s go back to our code and let’s talk about another operator,the more common operator and clearer andeasier to type operator for accessing properties and methods.Now this approach here that we just talked about,you will see sometimes in frameworks andlibraries because you can dynamically decide what property you’re trying to get.You can base it off a string.But it’s much clearer and easier to type the next one.All right, I’m going console.log the first name again.But I’m going to use a different operator, the dot operator.And it is just what it sounds like.Dot, then I can say, first name.The dot, is an operator, it’s a function.And when used after an Object like that, well,if I go back to my JavaScriptOperatorPrecedence.pdf,you’ll see it’s just second from the top, right after the parentheses for grouping.It’s left to right and it’s just a dot and it takes two parameters,the object that you’re looking at and the name of the property.Notice I don’t have to put this in quotes or something.Although that’s essentially what it’s doing.It’s taking the object and passing the stringthat represents the name of the value that you are looking for.But I don’t have to do that, that’s not a really accurate.You can’t do that.It will simply, the syntax parser will understand that after you put the dot,what you’ve actually typed will be the string that’s given to the dot.That’s just a lot faster to type.Person.firstname, and if I run this since I’m already outputting the person andfirstname again, I’ll just get the firstname again.So I refresh and there it is.You see that?So the dot operator acted exactly the same as the brackets operator here.This is Computed Member Access.And this is just called Member Access,the Member Access operator, members being members of the Object, right?Your fingers and your toes are members of your body.So these are looking for members of the Object, the pieces, the methods, andthe properties.So this went out and found this property because it’s just a string.It’s not called a method.It’s called a property.Okay, so I could console.log person.lastname.Very readable, very easy to type.And that’s what’s really happening.It went out and found that memory location,that reference by name that’s connected to that Object.And I could have set this value as well the same way.In fact remember that the other type of property you can have,as opposed to a primitive, is also another Object.So i can attach another set of names and values.Let’s says that person.address.I’m gonna make that instead of a string or a number ora Boolean, I’ll just make it another new Object.So it’s an Object sitting inside an Object andthen I can use the dot operator for example and add propertiesto my sub-object, my child object, inside of here.Now remember these are operators, so how do we know which one gets run first?Well, we go back and we see that the associativity ofthe Member Access operator is left-to-right.It has left associativity, meaning that the left most dot will get run first, getcalled first, because they’re functions, and then moving on to the right.So this one between person and address gets called first.So it says, okay, I’ll look at the person Object andlook for a property or a method that has that name.And then it finds that in memory.And this second dot operator is called and it says, okay, on that Object that I justfound in memory, I’ll look for a property or a method on that, called street.Now in this case it won’t find it but I’m setting a value soit will create it and give it that initial value.And I could just keep doing this.So I might have address.city.Let’s say New York.And state, let’s say New York.And you could see I could make this other subobject and subobjects and subobjects.And I could just keep going because it’s a left to right dot operator,left associative.And the Objects can keep containing Objects which can contain other Objectswhich can contain other Objects.So, this is very powerful.Realize that the Objects themselves and their properties andmethods are all just sitting in memory.These dots, these brackets, passing strings to them, they’re just functions.They’re just operators, a way to access that information.So now I have this Object sitting in memory.I could do a person.address.street and output that andit’ll go find it in memory running those two different operators.I could go person.address.city and it will find that.And I could on the same object just use a different operator.So I could go address using the computed, this is also left to right.If I look, it’s left to right, so I can also then just do another one.Let’s say, state.This is essentially doing the same thing.It looks at the object, finds a property ormethod called that, runs this operator first.Then the second operator, it’ll look for a state property on that.And the dot is doing the same thing.And they’re both simply accessing the same memory locations via the same names.So they’re just two different functions that are essentially doing the same thing.And I’ll refresh, and there I’m outputting my values,that are sitting in memory, using both operators.So again, Objects are name value pairs sitting in memory.They can contain other name value pairs, that is, other Objects.They can contain other properties, strings, Booleans.They can contain numbers.They can also contain functions, which are called methods.But we’re not going to quite get there yet,because there’s a couple other things we need to understand.But good enough for here.Remember that this is not the preferred way to create a new Object.We’ll get to that in just a second.And also remember that although we can use the dot orwe can use the computed, the bracket notation here for finding properties andmethods, the preferred approach is just using the dot operator.It’s very clean, it’s very clear, and it’s also easier to debug and find problems.So I always recommend that you use the dot operator unless you really need toaccess a property or properties using some kind of dynamic string.Some kind of string that can be changed, that you can look at programmatically.But to start with, always use the dot operator</summary></entry><entry><title type="html">Keywordthis</title><link href="http://localhost:4000/2018/12/14/KeyWordThis.html" rel="alternate" type="text/html" title="Keywordthis" /><published>2018-12-14T00:00:00-08:00</published><updated>2018-12-14T00:00:00-08:00</updated><id>http://localhost:4000/2018/12/14/KeyWordThis</id><content type="html" xml:base="http://localhost:4000/2018/12/14/KeyWordThis.html">&lt;p&gt;when a function is invoked a new execution context is created
Remember not to confuse this with the object that we’ve been discussing.
The object sitting in memory that is a function has properties and methods.
It has a name property and a code property where the code lives.
But when that code is invoked and
execution context is created and put on the execution stack.
And that determines how that code is Run, is executed.
So think of the execution context
as focusing on that code portion of that function object.
What happens when I run the code in that code property?
So we know that an execution context is created.
Each executions context has this variable environment.
Where the variables created inside that function live.
It has a reference to its outer environment.
Its outer lexical environment, where it sits physically in the code,
which tells it how to look down the scope chain.
In other words, if I ask for a variable and
it’s not there inside that function’s variable environment.
It’ll go out and out further, and all the way out until it reaches the global
environment looking for that variable or that function.
So it has that outer reference.
And we also know that in JavaScript engine every time
an execution context is created, that is every time a function is Run.
It gives us, without us having to create it, declare it or
anything, it gives us this variable called this, which can be useful.
And this will be pointing at a different object,
a different thing, depending on how the function is invoked.
This can cause a lot of confusion.
There are a few scenarios where this
will be changed depending on how the function is called.
For the JavaScript engine will decide that this should point to something different.
That the this keyword is a particular object or another,
depending on where the function is and how it’s called.
So let’s take a look at a couple of these scenarios, and
we’ll see this again later in the course as well.
So, the this keyword.
I once again have my empty app.js file, and
we’ll use some simple examples to explain what this,
the keyword this will be under certain circumstances.
Now you maybe thinking that you’d like to see some more concrete complete examples.
I agree.
As this course goes on especially toward the end, we’ll look at far more complex
examples of the concepts that we’re using in the real world and
in very popular JavaScript libraries and frameworks.
But I believe it’s important first to understand the concept and
not get bogged down in the details of implementation of more complex examples.
So right now we’re focusing on just
understanding what’s happening under the hood with JavaScript.
And then later we’ll build on that knowledge with more complex example.
For now, let’s move on talking about this keyword.
We’ve already seen that this is immediately available, the keyword this.
Even at the global execution context level.
So I can run this, and inside the browser, it’s going to show me the window object.
Because this points to the global object at this level in the code.
And inside the browser, the global object is,
as you might recall, the Window object.
Now let’s look at another example, let’s say I have a function.
I’ll just call it a, and I’m going to log this.
And then, I’ll invoke a.
Remember that invoking a, means run that code property
which contains all the lines of code inside the function.
And the first thing it does is create that execution context, and one of that
pieces of the puzzle is the creation of the keyword this.
So what will the keyword this be
inside the execution context that’s created by invoking a?
Execution context for running the a function.
Now let’s take a look.
It’s also the Window object.
So when you create a function, the this keyword is still going to
point to the global object.
If you decided to use this, if you’re simply invoking the function.
Similarly, if I use a function expression
to set up the object, and then set that equal to a variable.
Actually I mean this.
So, var b gets this function expression to declare it, to create it.
What will this be in that case?
Well, I’ll go ahead and
invoke b, using the variable name to point to that function.
And it’s still Window.
So whenever I create a function
that’s simply a function expression or a function statement.
Creating a function at this level in the code,
then this will point to the global object.
And that’s true even though there’s actually
three execution contexts that we see here.
The global one, then the one that’s created when a is invoked, and
another execution context that’s created when b is invoked.
And in each of those cases, they get their own this keyword.
But in all those cases, the keyword points to the same address,
the same location in your computer’s memory.
So they’re all pointing at the global object.
Makes sense?
That means you could even do strange things like this.newvariable
let’s say equals hello.
I’ve attached it to the global object.
So after I call a, I could actually console.log newvariable.
Cuz that’s been created and using the dot operator,
I’ve attached a new variable to the global object.
And remember,
any variables attached to the global object, I can just reference like that.
I don’t need to use the dot operator.
It just assumes I’m asking for a variable on the global object.
So I can refresh this and
actually see that hello, kind of strange.
If you don’t understand what this keyword is pointing to and
you think you’re somehow attaching this to the function, you’re not.
You’re actually crashing into the global namespace and
you could cause yourself a lot of problems.
So when you’re just invoking the function, this points to the global variable.
However, you may have seen something that looks like this when learning JavaScript.
We’re gonna talk about that later in the course about what circumstance
when you would use the this variable inside a function like this.
Now that said, what about an object method?
Let me create a little space here and I’ll create a new object literal and
now that we understand function expressions,
I can do something that we haven’t done before inside an object literal.
I can create a method.
Remember, if the value is a primitive, it’s called a property.
And if the value a function, it’s called a method.
So, I’ll create a name-value pair.
I’ll just call it name, so we can recognize the object and
I’ll call it the c object and then a comma and I’ll create a method.
I’ll do log: so that’s the name and
then the value I want to create a function object.
So, I’ll just use a function expression.
An anonymous function, no name and
then I’ll console.log this and
then I’ll call c.log So
now I can invoke the function that was created inside this object literal,
which is attached to this log.
So this is the log method of the object c.
See that?
What will this turn out to be?
Remember every time a function is invoked, a new execution context is created and
the JavaScript engine decides what that keyword,
the keyword this should be pointing to.
In these other cases, it was the window object.
But in this case, it’s a method on an object and
that means, see that there at the bottom?
In the case where a function is actually a method
attached to an object, this keyword becomes
the object that that method is sitting inside of c.
See that?
These functions, this keyword.
The JavaScript engine said, you’re attached to an object.
So when you see, when you use the this keyword I’m going to
be pointing at that very object that contains you.
So I could actually say,
this.name = ‘Updated c object’
And then when this is logged, see that?
I changed that property on this parent object,
the object that holds the function.
So that’s useful.
I can mutate that is change the object,
that contains me if I’m a method of that object by using of this keyword.
You can imagine that can be very useful to be able to access other properties and
methods on the same object that a particular method lives on.
This is very common to use and it’s neat.
Now there’s one more thing to show you and
this a lot of people feel is a bug in JavaScript.
Now you might be saying, what do you mean a bug in JavaScript?
Well, JavaScript is a programming language and the engines and the language was
designed by people and so decisions were made about how things should work.
And in this one case, this decision a lot of people feel is wrong.
Let me show you.
Let’s suppose that I create a function inside this method, we can do that right.
I’m gonna call it setname, I’ll use a variable and
I’ll set a function expression.
This time, I’ll pass a variable to my function.
Let’s say, new name.
I can do that.
And inside here, I’m gonna say this.name = newname.
So, I’m trying to update or
mutate my object with this newname.
And then let’s say that here,
I’m going to go ahead and call setname and
I’ll say ‘Updated again!
The c object’) and
then console.log(this) again.
So I mutate it and I should see ‘Updated c object’.
I create a function that also, well when executed, create a new execution context.
And I would expect, personally that this keyword would
still point to the containing object,
because it’s a function inside of a function, inside of an object.
And since this keyword points to the object, I would expect, well, one more
function down and it’ll still point to the object and I can mutate it, change it.
So I would expect that after calling this setname function,
I’ll see updated again the c object as the name on that second console.log.
Let’s try it.
Well, that’s a problem.
“Updated c object” and Updated c object”.
Meaning, this ran, but
this didn’t seem to do anything or did it.
Oh, let’s try going back and taking a look
at the window object, the global object.
And if I take a good look, look at that.
See that?
That name property here was instead created and
added by the equals operator on the global object.
That means that this internal function, when its execution
context was created, the this key word points to the global object,
even though it’s sitting kind of inside an object that I created.
I think that’s wrong and a lot of people do, but
that’s the way JavaScript works in this case and
there’s not a lot we can do about it at this point.
So what can we do when I have this kind of scenario?
To make sure that I’m using the right object.
That this keyword isn’t causing me to make an unintended error.
Well there’s a very common pattern that we can use in this case.
And we’ll understand it because We understand
that objects are set by reference.
Now that we understand that, we can understand this pattern.
I can simply say I’m going to set a variable.
I’ll call it self.
Some people call it that, but I like self.
Because I’m inside this object.
And I’m going to set that equal to this.
It was the very first line of my object method.
So what happened right here?
Well, now we have a new variable called self, and
since these are objects, it’s going to be set equal to by reference.
So self will be pointing at the same location in memory as the this keyword.
And right now, the this keyword on this line of code is pointing to
my whole object.
And then for sanity’s sake, we simply use self everywhere where we normally
would have used this, even inside these sub-functions.
That way I don’t have to think about, am I pointing to the right object?
This is still pointing.
The self variable is still pointing to the same location in memory as this.
So when I mutate it, when I change it, when I add something to it or change it or
whatever, it’s going to update the appropriate thing,
in this case, my whole object.
So self, I can log that, and then when I look
at this new function that I created, and this gets executed right here.
I don’t even worry about the this variable.
I simply say self.
So what’s going to happen?
Well, self isn’t declared inside this function.
So the JavaScript engine will look down the scope chain.
Where is this function sitting physically in the code?
Well, right inside here.
So we can see that’ll it just go outside to the next area outside, the outer
lexical reference, and look for it, a variable called self and it will find it.
And so this right here, the self variable inside this function,
will end up being this one here.
And that’s still pointing to my whole object.
So I can mutate my object here, as well.
So now, this should show up properly.
I have a proper reference to my object.
And then I just use it from there on out, just for sanity’s sake, so
I don’t have to think about it.
And then I’ll mutate it, I’ll change it.
And then I’ll create a function, and
I’ll call that function and that will mutate the object.
And I’ll put it again.
So this time I should see, look at that.
That’s proper.
That’s what I expected.
So what did we learn?
We learned that no programming language is perfect.
They all have their quirks, and JavaScript certainly isn’t an exception.
But there are patterns we can use to get around
any problems the programming language might have.
Now I also wanna make mention that this pattern you’ll see very often if
you’re working in any real-world JavaScript scenarios.
However, the let keyword, which will be an alternative
to the var keyword, is meant to clear some of these problems up.
So as that becomes available in modern browsers,
and depending on the kind of project you’re working on,
if you’re working on a web project and you don’t have to worry about older browsers.
That’s something that you’ll soon start to be able to use,
and bonus lectures in this course will help with that, as time goes on.
But for now, realize that this pattern is a good one.
It is used quite often and is quite useful.
So we’ve seen the this key word.
It’s the global variable, or
the global object, when just invoking a function like this.
And when the function is a method of an object,
the this keyword points to the object.
However, any internal functions have a problem.
So we can use this concept of setting a variable equal to this,
and then just carrying that with us the rest of the way to
make sure that we don’t run across any unintentional errors,
or somehow throw things onto the global object that we didn’t mean to.
All right, let’s move on.&lt;/p&gt;</content><author><name>David Odhiambo</name></author><summary type="html">when a function is invoked a new execution context is created Remember not to confuse this with the object that we’ve been discussing. The object sitting in memory that is a function has properties and methods. It has a name property and a code property where the code lives. But when that code is invoked and execution context is created and put on the execution stack. And that determines how that code is Run, is executed. So think of the execution context as focusing on that code portion of that function object. What happens when I run the code in that code property? So we know that an execution context is created. Each executions context has this variable environment. Where the variables created inside that function live. It has a reference to its outer environment. Its outer lexical environment, where it sits physically in the code, which tells it how to look down the scope chain. In other words, if I ask for a variable and it’s not there inside that function’s variable environment. It’ll go out and out further, and all the way out until it reaches the global environment looking for that variable or that function. So it has that outer reference. And we also know that in JavaScript engine every time an execution context is created, that is every time a function is Run. It gives us, without us having to create it, declare it or anything, it gives us this variable called this, which can be useful. And this will be pointing at a different object, a different thing, depending on how the function is invoked. This can cause a lot of confusion. There are a few scenarios where this will be changed depending on how the function is called. For the JavaScript engine will decide that this should point to something different. That the this keyword is a particular object or another, depending on where the function is and how it’s called. So let’s take a look at a couple of these scenarios, and we’ll see this again later in the course as well. So, the this keyword. I once again have my empty app.js file, and we’ll use some simple examples to explain what this, the keyword this will be under certain circumstances. Now you maybe thinking that you’d like to see some more concrete complete examples. I agree. As this course goes on especially toward the end, we’ll look at far more complex examples of the concepts that we’re using in the real world and in very popular JavaScript libraries and frameworks. But I believe it’s important first to understand the concept and not get bogged down in the details of implementation of more complex examples. So right now we’re focusing on just understanding what’s happening under the hood with JavaScript. And then later we’ll build on that knowledge with more complex example. For now, let’s move on talking about this keyword. We’ve already seen that this is immediately available, the keyword this. Even at the global execution context level. So I can run this, and inside the browser, it’s going to show me the window object. Because this points to the global object at this level in the code. And inside the browser, the global object is, as you might recall, the Window object. Now let’s look at another example, let’s say I have a function. I’ll just call it a, and I’m going to log this. And then, I’ll invoke a. Remember that invoking a, means run that code property which contains all the lines of code inside the function. And the first thing it does is create that execution context, and one of that pieces of the puzzle is the creation of the keyword this. So what will the keyword this be inside the execution context that’s created by invoking a? Execution context for running the a function. Now let’s take a look. It’s also the Window object. So when you create a function, the this keyword is still going to point to the global object. If you decided to use this, if you’re simply invoking the function. Similarly, if I use a function expression to set up the object, and then set that equal to a variable. Actually I mean this. So, var b gets this function expression to declare it, to create it. What will this be in that case? Well, I’ll go ahead and invoke b, using the variable name to point to that function. And it’s still Window. So whenever I create a function that’s simply a function expression or a function statement. Creating a function at this level in the code, then this will point to the global object. And that’s true even though there’s actually three execution contexts that we see here. The global one, then the one that’s created when a is invoked, and another execution context that’s created when b is invoked. And in each of those cases, they get their own this keyword. But in all those cases, the keyword points to the same address, the same location in your computer’s memory. So they’re all pointing at the global object. Makes sense? That means you could even do strange things like this.newvariable let’s say equals hello. I’ve attached it to the global object. So after I call a, I could actually console.log newvariable. Cuz that’s been created and using the dot operator, I’ve attached a new variable to the global object. And remember, any variables attached to the global object, I can just reference like that. I don’t need to use the dot operator. It just assumes I’m asking for a variable on the global object. So I can refresh this and actually see that hello, kind of strange. If you don’t understand what this keyword is pointing to and you think you’re somehow attaching this to the function, you’re not. You’re actually crashing into the global namespace and you could cause yourself a lot of problems. So when you’re just invoking the function, this points to the global variable. However, you may have seen something that looks like this when learning JavaScript. We’re gonna talk about that later in the course about what circumstance when you would use the this variable inside a function like this. Now that said, what about an object method? Let me create a little space here and I’ll create a new object literal and now that we understand function expressions, I can do something that we haven’t done before inside an object literal. I can create a method. Remember, if the value is a primitive, it’s called a property. And if the value a function, it’s called a method. So, I’ll create a name-value pair. I’ll just call it name, so we can recognize the object and I’ll call it the c object and then a comma and I’ll create a method. I’ll do log: so that’s the name and then the value I want to create a function object. So, I’ll just use a function expression. An anonymous function, no name and then I’ll console.log this and then I’ll call c.log So now I can invoke the function that was created inside this object literal, which is attached to this log. So this is the log method of the object c. See that? What will this turn out to be? Remember every time a function is invoked, a new execution context is created and the JavaScript engine decides what that keyword, the keyword this should be pointing to. In these other cases, it was the window object. But in this case, it’s a method on an object and that means, see that there at the bottom? In the case where a function is actually a method attached to an object, this keyword becomes the object that that method is sitting inside of c. See that? These functions, this keyword. The JavaScript engine said, you’re attached to an object. So when you see, when you use the this keyword I’m going to be pointing at that very object that contains you. So I could actually say, this.name = ‘Updated c object’ And then when this is logged, see that? I changed that property on this parent object, the object that holds the function. So that’s useful. I can mutate that is change the object, that contains me if I’m a method of that object by using of this keyword. You can imagine that can be very useful to be able to access other properties and methods on the same object that a particular method lives on. This is very common to use and it’s neat. Now there’s one more thing to show you and this a lot of people feel is a bug in JavaScript. Now you might be saying, what do you mean a bug in JavaScript? Well, JavaScript is a programming language and the engines and the language was designed by people and so decisions were made about how things should work. And in this one case, this decision a lot of people feel is wrong. Let me show you. Let’s suppose that I create a function inside this method, we can do that right. I’m gonna call it setname, I’ll use a variable and I’ll set a function expression. This time, I’ll pass a variable to my function. Let’s say, new name. I can do that. And inside here, I’m gonna say this.name = newname. So, I’m trying to update or mutate my object with this newname. And then let’s say that here, I’m going to go ahead and call setname and I’ll say ‘Updated again! The c object’) and then console.log(this) again. So I mutate it and I should see ‘Updated c object’. I create a function that also, well when executed, create a new execution context. And I would expect, personally that this keyword would still point to the containing object, because it’s a function inside of a function, inside of an object. And since this keyword points to the object, I would expect, well, one more function down and it’ll still point to the object and I can mutate it, change it. So I would expect that after calling this setname function, I’ll see updated again the c object as the name on that second console.log. Let’s try it. Well, that’s a problem. “Updated c object” and Updated c object”. Meaning, this ran, but this didn’t seem to do anything or did it. Oh, let’s try going back and taking a look at the window object, the global object. And if I take a good look, look at that. See that? That name property here was instead created and added by the equals operator on the global object. That means that this internal function, when its execution context was created, the this key word points to the global object, even though it’s sitting kind of inside an object that I created. I think that’s wrong and a lot of people do, but that’s the way JavaScript works in this case and there’s not a lot we can do about it at this point. So what can we do when I have this kind of scenario? To make sure that I’m using the right object. That this keyword isn’t causing me to make an unintended error. Well there’s a very common pattern that we can use in this case. And we’ll understand it because We understand that objects are set by reference. Now that we understand that, we can understand this pattern. I can simply say I’m going to set a variable. I’ll call it self. Some people call it that, but I like self. Because I’m inside this object. And I’m going to set that equal to this. It was the very first line of my object method. So what happened right here? Well, now we have a new variable called self, and since these are objects, it’s going to be set equal to by reference. So self will be pointing at the same location in memory as the this keyword. And right now, the this keyword on this line of code is pointing to my whole object. And then for sanity’s sake, we simply use self everywhere where we normally would have used this, even inside these sub-functions. That way I don’t have to think about, am I pointing to the right object? This is still pointing. The self variable is still pointing to the same location in memory as this. So when I mutate it, when I change it, when I add something to it or change it or whatever, it’s going to update the appropriate thing, in this case, my whole object. So self, I can log that, and then when I look at this new function that I created, and this gets executed right here. I don’t even worry about the this variable. I simply say self. So what’s going to happen? Well, self isn’t declared inside this function. So the JavaScript engine will look down the scope chain. Where is this function sitting physically in the code? Well, right inside here. So we can see that’ll it just go outside to the next area outside, the outer lexical reference, and look for it, a variable called self and it will find it. And so this right here, the self variable inside this function, will end up being this one here. And that’s still pointing to my whole object. So I can mutate my object here, as well. So now, this should show up properly. I have a proper reference to my object. And then I just use it from there on out, just for sanity’s sake, so I don’t have to think about it. And then I’ll mutate it, I’ll change it. And then I’ll create a function, and I’ll call that function and that will mutate the object. And I’ll put it again. So this time I should see, look at that. That’s proper. That’s what I expected. So what did we learn? We learned that no programming language is perfect. They all have their quirks, and JavaScript certainly isn’t an exception. But there are patterns we can use to get around any problems the programming language might have. Now I also wanna make mention that this pattern you’ll see very often if you’re working in any real-world JavaScript scenarios. However, the let keyword, which will be an alternative to the var keyword, is meant to clear some of these problems up. So as that becomes available in modern browsers, and depending on the kind of project you’re working on, if you’re working on a web project and you don’t have to worry about older browsers. That’s something that you’ll soon start to be able to use, and bonus lectures in this course will help with that, as time goes on. But for now, realize that this pattern is a good one. It is used quite often and is quite useful. So we’ve seen the this key word. It’s the global variable, or the global object, when just invoking a function like this. And when the function is a method of an object, the this keyword points to the object. However, any internal functions have a problem. So we can use this concept of setting a variable equal to this, and then just carrying that with us the rest of the way to make sure that we don’t run across any unintentional errors, or somehow throw things onto the global object that we didn’t mean to. All right, let’s move on.</summary></entry></feed>